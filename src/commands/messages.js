import { bufferService } from '../storage/buffer.js';
import { geminiService } from '../services/gemini.js';
import { taskService } from '../services/tasks.js';
import { taskDetectionPrompt } from '../prompts/index.js';
import { formatMessageForAI, safeReply } from '../utils/telegram.js';

export function setupMessageHandler(bot) {
  bot.on('message', async (ctx) => {
    const chatId = ctx.chat.id;
    const message = ctx.message;
    const text = message.text;

    if (!text || text.startsWith('/')) return;

    // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä
    bufferService.addMessage(chatId, message);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∑–∞–¥–∞—á–∏ –∫–∞–∂–¥—ã–µ N —Å–æ–æ–±—â–µ–Ω–∏–π
    if (bufferService.shouldCheckTasks(chatId)) {
      await checkForTasks(ctx, chatId);
    }
  });
}

async function checkForTasks(ctx, chatId) {
  const last10Messages = bufferService.getLastMessages(chatId, 10);
  const messagesText = last10Messages.map(m => formatMessageForAI(m)).join('\n');

  try {
    const taskAnalysis = await geminiService.analyzeForTasks(taskDetectionPrompt(messagesText));

    if (taskAnalysis.hasTask && taskAnalysis.priority === 'high') {
      const taskData = {
        taskText: taskAnalysis.taskText,
        author: taskAnalysis.author,
        priority: taskAnalysis.priority,
        chatId: chatId
      };

      const taskId = taskService.addPendingTask(taskData);

      await safeReply(ctx,
        `üö® **–í–ê–ñ–ù–ê–Ø –ó–ê–î–ê–ß–ê –û–ë–ù–ê–†–£–ñ–ï–ù–ê!**\n\n` +
        `üìù ${taskAnalysis.taskText}\n` +
        `üë§ –ê–≤—Ç–æ—Ä: ${taskAnalysis.author}\n` +
        `‚ö° –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: üî¥ –í—ã—Å–æ–∫–∏–π`,
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [[
              { text: 'üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∑–∞–¥–∞—á—É', callback_data: `save_${taskId}` }
            ]]
          }
        }
      );
    }
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∑–∞–¥–∞—á:', error);
  }
}
