import { bufferService } from '../storage/buffer.js';
import { geminiService } from '../services/gemini.js';
import { predictPrompt } from '../prompts/index.js';
import { formatMessageForAI, safeReply } from '../utils/telegram.js';

export function setupPredictCommand(bot) {
  bot.command('predict', async (ctx) => {
    const chatId = ctx.chat.id;
    const buf = bufferService.getBuffer(chatId);

    if (!buf || buf.length === 0) {
      return ctx.reply('üì≠ –ë—É—Ñ–µ—Ä –ø—É—Å—Ç. –ù–µ—á–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è.');
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –±–æ–ª–µ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
    const recentMessages = buf.slice(-20); // –ë–µ—Ä—ë–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 —Å–æ–æ–±—â–µ–Ω–∏–π
    const textBasic = recentMessages.map(m => formatMessageForAI(m)).join('\n');

    try {
      const prediction = await geminiService.generatePrediction(predictPrompt(textBasic));

      await safeReply(ctx, `üîÆ ${prediction}`, {
        parse_mode: 'Markdown'
      });
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è:', error);
      await safeReply(ctx, '‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–∏ —Ä–∞–∑–≤–∏—Ç–∏—è —á–∞—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  });
}
